<?xml version="1.0"?>

<!--
** Modified Firefox 57+ bindings offered in ***********************************************
** chrome://global/content/bindings/autocomplete.xml#autocomplete-rich-result-popup *******
** and ************************************************************************************
** chrome://browser/content/urlbarBindings.xml#urlbar-rich-result-popup *******************
** to simulate pre-Fx48 look of location bars autocomplete popup and removed all default **
** default comments to reduce file size. **************************************************
-->

<!DOCTYPE bindings [
<!ENTITY % notificationDTD SYSTEM "chrome://global/locale/notification.dtd">
%notificationDTD;
<!ENTITY % browserDTD SYSTEM "chrome://browser/locale/browser.dtd">
%browserDTD;
<!ENTITY % brandDTD SYSTEM "chrome://branding/locale/brand.dtd">
%brandDTD;
]>

<bindings id="urlbarBindings"
		  xmlns="http://www.mozilla.org/xbl"
          xmlns:html="http://www.w3.org/1999/xhtml"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">

  <binding id="urlbar-rich-result-popup" extends="chrome://global/content/bindings/autocomplete.xml#autocomplete-rich-result-popup">

    <resources>
      <stylesheet src="chrome://browser/content/search/searchbarBindings.css"/>
      <stylesheet src="chrome://browser/skin/searchbar.css"/>
    </resources>

    <content ignorekeys="true" level="top" consumeoutsideclicks="never"
             aria-owns="richlistbox">
      <xul:deck anonid="search-suggestions-notification"
                align="center"
                role="alert"
                selectedIndex="0">
        <!-- OPT-OUT -->
        <xul:hbox flex="1" align="center" anonid="search-suggestions-opt-out">
          <xul:image class="ac-site-icon" type="searchengine"/>
          <xul:hbox anonid="search-suggestions-hint-typing">
            <xul:description class="ac-title-text">&brandShortName;</xul:description>
          </xul:hbox>
          <xul:hbox anonid="search-suggestions-hint-box" flex="1">
            <xul:description id="search-suggestions-hint">
              <html:span class="prefix">&#x1f4a1; &urlbar.searchSuggestionsNotification.hintPrefix;</html:span>
              <html:span>&urlbar.searchSuggestionsNotification.hint;</html:span>
            </xul:description>
          </xul:hbox>
          <xul:label id="search-suggestions-change-settings"
                     class="text-link"
                     role="link"
                     value="&urlbar.searchSuggestionsNotification.changeSettingsWin;"
                     accesskey="&urlbar.searchSuggestionsNotification.changeSettingsWin.accesskey;"
                     onclick="openPreferences('paneSearch', {origin: 'searchChangeSettings'});"
                     control="search-suggestions-change-settings"/>
        </xul:hbox>
      </xul:deck>
      <xul:richlistbox anonid="richlistbox" class="autocomplete-richlistbox"
                       flex="1"/>
      <xul:hbox anonid="footer">
        <children/>
        <xul:vbox anonid="one-off-search-buttons"
                  class="search-one-offs"
                  compact="true"
                  includecurrentengine="true"
                  disabletab="true"
                  flex="1"/>
      </xul:hbox>
    </content>

    <implementation>
      <field name="DOMWindowUtils">
        window.QueryInterface(Ci.nsIInterfaceRequestor)
              .getInterface(Ci.nsIDOMWindowUtils);
      </field>

      <field name="_maxResults">0</field>

      <field name="_bundle" readonly="true">
        Cc["@mozilla.org/intl/stringbundle;1"].
          getService(Ci.nsIStringBundleService).
          createBundle("chrome://browser/locale/places/places.properties");
      </field>

      <field name="searchSuggestionsNotification" readonly="true">
        document.getAnonymousElementByAttribute(
          this, "anonid", "search-suggestions-notification"
        );
      </field>

      <field name="footer" readonly="true">
        document.getAnonymousElementByAttribute(this, "anonid", "footer");
      </field>

      <field name="oneOffSearchButtons" readonly="true">
        document.getAnonymousElementByAttribute(this, "anonid",
                                                "one-off-search-buttons");
      </field>

      <field name="_oneOffSearchesEnabled">false</field>

      <field name="_overrideValue">null</field>
      <property name="overrideValue"
                onget="return this._overrideValue;"
                onset="this._overrideValue = val; return val;"/>

      <method name="onPopupClick">
        <parameter name="aEvent"/>
        <body><![CDATA[
          if (aEvent.button == 2) {
            // Ignore right-clicks.
            return;
          }
          // Otherwise "call super" -- do what autocomplete-base-popup does.
          let controller = this.view.QueryInterface(Components.interfaces.nsIAutoCompleteController);
          controller.handleEnter(true, aEvent);
        ]]></body>
      </method>

      <method name="enableOneOffSearches">
        <parameter name="enable"/>
        <body><![CDATA[
          this._oneOffSearchesEnabled = enable;
          if (enable) {
            this.oneOffSearchButtons.telemetryOrigin = "urlbar";
            this.oneOffSearchButtons.style.display = "-moz-box";
            // Set .textbox first, since the popup setter will cause
            // a _rebuild call that uses it.
            this.oneOffSearchButtons.textbox = this.input;
            this.oneOffSearchButtons.popup = this;
          } else {
            this.oneOffSearchButtons.telemetryOrigin = null;
            this.oneOffSearchButtons.style.display = "none";
            this.oneOffSearchButtons.textbox = null;
            this.oneOffSearchButtons.popup = null;
          }
        ]]></body>
      </method>

      <!-- Override this so that navigating between items results in an item
           always being selected. -->
      <method name="getNextIndex">
        <parameter name="reverse"/>
        <parameter name="amount"/>
        <parameter name="index"/>
        <parameter name="maxRow"/>
        <body><![CDATA[
          if (maxRow < 0)
            return -1;

          let newIndex = index + (reverse ? -1 : 1) * amount;

          // We only want to wrap if navigation is in any direction by one item,
          // otherwise we clamp to one end of the list.
          // ie, hitting page-down will only cause is to wrap if we're already
          // at one end of the list.

          // Allow the selection to be removed if the first result is not a
          // heuristic result.
          if (!this._isFirstResultHeuristic) {
            if (reverse && index == -1 || newIndex > maxRow && index != maxRow)
              newIndex = maxRow;
            else if (!reverse && index == -1 || newIndex < 0 && index != 0)
              newIndex = 0;

            if (newIndex < 0 && index == 0 || newIndex > maxRow && index == maxRow)
              newIndex = -1;

            return newIndex;
          }

          // Otherwise do not allow the selection to be removed.
          if (newIndex < 0) {
            newIndex = index > 0 ? 0 : maxRow;
          } else if (newIndex > maxRow) {
            newIndex = index < maxRow ? maxRow : 0;
          }
          return newIndex;
        ]]></body>
      </method>

      <property name="_isFirstResultHeuristic" readonly="true">
        <getter>
          <![CDATA[
            // The popup usually has a special "heuristic" first result (added
            // by UnifiedComplete.js) that is automatically selected when the
            // popup opens.
            return this.input.mController.matchCount > 0 &&
                   this.input.mController
                             .getStyleAt(0)
                             .split(/\s+/).indexOf("heuristic") > 0;
          ]]>
        </getter>
      </property>

      <property name="maxResults">
        <getter>
          <![CDATA[
            if (!this._maxResults) {
              this._maxResults = Services.prefs.getIntPref("browser.urlbar.maxRichResults");
            }
            return this._maxResults;
          ]]>
        </getter>
        <setter>
          <![CDATA[
            return this._maxResults = parseInt(val);
          ]]>
        </setter>
      </property>

      <!-- This is set either to undefined or to a new object containing
           { start, end } margin values in pixels. These are used to align the
           results to the input field. -->
      <property name="margins"
                onget="return this._margins;">
        <setter>
          <![CDATA[
          this._margins = val;

          if (val) {
            /* eslint-disable no-multi-spaces */
            let paddingInCSS =
                3   // .autocomplete-richlistbox padding-left/right
              + 6   // .ac-site-icon margin-inline-start
              + 16  // .ac-site-icon width
              + 6;  // .ac-site-icon margin-inline-end
            /* eslint-enable no-multi-spaces */
            let actualVal = Math.round(val.start) - paddingInCSS;
            let actualValEnd = Math.round(val.end);
            this.style.setProperty("--item-padding-start", actualVal + "px");
            this.style.setProperty("--item-padding-end", actualValEnd + "px");
          } else {
            this.style.removeProperty("--item-padding-start");
            this.style.removeProperty("--item-padding-end");
          }

          return val;
          ]]>
        </setter>
      </property>

      <method name="openAutocompletePopup">
        <parameter name="aInput"/>
        <parameter name="aElement"/>
        <body>
          <![CDATA[
          // initially the panel is hidden
          // to avoid impacting startup / new window performance
          aInput.popup.hidden = false;

          this._openAutocompletePopup(aInput, aElement);
          ]]>
        </body>
      </method>

      <method name="_openAutocompletePopup">
        <parameter name="aInput"/>
        <parameter name="aElement"/>
        <body><![CDATA[
          if (this.mPopupOpen) {
            return;
          }

          // Set the direction of the popup based on the textbox (bug 649840).
          // getComputedStyle causes a layout flush, so avoid calling it if a
          // direction has already been set.
          if (!this.style.direction) {
            this.style.direction =
              aElement.ownerGlobal.getComputedStyle(aElement).direction;
          }
          let popupDirection = this.style.direction;

          // Make the popup span the width of the window.  First, set its width.
          let documentRect =
            this.DOMWindowUtils
                .getBoundsWithoutFlushing(window.document.documentElement);
          let width = documentRect.right - documentRect.left;
          this.setAttribute("width", Math.round(document.getElementById("urlbar").getBoundingClientRect().width));

          // Now make its starting margin negative so that its leading edge
          // aligns with the window border.
          let elementRect =
            this.DOMWindowUtils.getBoundsWithoutFlushing(aElement);
          if (popupDirection == "rtl") {
            let offset = elementRect.right - documentRect.right;
            this.style.marginRight = offset + "px";
          } else {
            let offset = documentRect.left - elementRect.left;
            this.style.marginLeft = offset + "px";
          }

          // Keep the popup items' site icons aligned with the urlbar's identity
          // icon if it's not too far from the edge of the window.  We define
          // "too far" as "more than 30% of the window's width AND more than
          // 250px".  Do this *before* adding any items because when the new
          // value of the margins are different from the previous value, over-
          // and underflow must be handled for each item already in the popup.
          let needsHandleOverUnderflow = false;
          let boundToCheck = popupDirection == "rtl" ? "right" : "left";
          let inputRect = this.DOMWindowUtils.getBoundsWithoutFlushing(aInput);
          let startOffset = Math.abs(inputRect[boundToCheck] - documentRect[boundToCheck]);
          let alignSiteIcons = startOffset / width <= 0.3 || startOffset <= 250;
          if (alignSiteIcons) {
            // Calculate the end margin if we have a start margin.
            let boundToCheckEnd = popupDirection == "rtl" ? "left" : "right";
            let endOffset = Math.abs(inputRect[boundToCheckEnd] -
                                     documentRect[boundToCheckEnd]);
            if (endOffset > startOffset * 2) {
              // Provide more space when aligning would result in an unbalanced
              // margin. This allows the location bar to be moved to the start
              // of the navigation toolbar to reclaim space for results.
              endOffset = startOffset;
            }
            let identityIcon = document.getElementById("identity-icon");
            let identityRect =
              this.DOMWindowUtils.getBoundsWithoutFlushing(identityIcon);
            let start = popupDirection == "rtl" ?
                        documentRect.right - identityRect.right :
                        identityRect.left;
            if (!this.margins || start != this.margins.start ||
                                 endOffset != this.margins.end ||
                                 width != this.margins.width) {
              this.margins = { start, end: endOffset, width };
              needsHandleOverUnderflow = true;
            }
          } else if (this.margins) {
            // Reset the alignment so that the site icons are positioned
            // according to whatever's in the CSS.
            this.margins = undefined;
            needsHandleOverUnderflow = true;
          }

          // Now that the margins have been set, start adding items (via
          // _invalidate).
          this.mInput = aInput;
          aInput.controller.setInitiallySelectedIndex(this._isFirstResultHeuristic ? 0 : -1);
          this.view = aInput.controller.QueryInterface(Components.interfaces.nsITreeView);
          this._invalidate();

          try {
            let whichNotification = aInput.whichSearchSuggestionsNotification;
            if (whichNotification != "none") {
              // Update the impressions count on real popupshown, since there's
              // no guarantee openPopup will be respected by the platform.
              // Though, we must ensure the handled event is the expected one.
              let impressionId = this._searchSuggestionsImpressionId = {};
              this.addEventListener("popupshown", () => {
                if (this._searchSuggestionsImpressionId == impressionId)
                  aInput.updateSearchSuggestionsNotificationImpressions(whichNotification);
              }, {once: true});
              this._showSearchSuggestionsNotification(whichNotification, popupDirection);
            } else if (this.classList.contains("showSearchSuggestionsNotification")) {
              this._hideSearchSuggestionsNotification();
            }
          } catch (ex) {
            // Not critical for the urlbar functionality, just report the error.
            Components.utils.reportError(ex);
          }

          // Position the popup below the navbar.  To get the y-coordinate,
          // which is an offset from the bottom of the input, subtract the
          // bottom of the navbar from the buttom of the input.
          let yOffset = Math.round(
            this.DOMWindowUtils.getBoundsWithoutFlushing(document.getElementById("nav-bar")).bottom -
            this.DOMWindowUtils.getBoundsWithoutFlushing(aInput).bottom);

		  var x_position = document.getElementById("urlbar").getBoundingClientRect().x;
		  var y_position = -1;
			
          this.openPopup(aElement, "after_start", x_position, y_position, false, false);

          // Do this immediately after we've requested the popup to open. This
          // will cause sync reflows but prevents flickering.
          if (needsHandleOverUnderflow) {
            for (let item of this.richlistbox.childNodes) {
              item.handleOverUnderflow();
            }
          }
        ]]></body>
      </method>

      <method name="_showSearchSuggestionsNotification">
        <parameter name="whichNotification"/>
        <parameter name="popupDirection"/>
        <body>
          <![CDATA[
          if (whichNotification == "opt-out") {
            if (this.margins) {
              this.searchSuggestionsNotification.style.paddingInlineStart =
                this.margins.start + "px";
            } else {
              this.searchSuggestionsNotification.style.removeProperty("padding-inline-start");
            }

            // We want to animate the opt-out hint only once.
            if (!this._firstSearchSuggestionsNotification) {
              this._firstSearchSuggestionsNotification = true;
              this.searchSuggestionsNotification.setAttribute("animate", "true");
            }
          }

          this.searchSuggestionsNotification.setAttribute("aria-describedby",
                                                          "search-suggestions-hint");

          // With the notification shown, the listbox's height can sometimes be
          // too small when it's flexed, as it normally is.  Also, it can start
          // out slightly scrolled down.  Both problems appear together, most
          // often when the popup is very narrow and the notification's text
          // must wrap.  Work around them by removing the flex.
          //
          // But without flexing the listbox, the listbox's height animation
          // sometimes fails to complete, leaving the popup too tall.  Work
          // around that problem by disabling the listbox animation.
          this.richlistbox.flex = 0;
          this.setAttribute("dontanimate", "true");

          this.classList.add("showSearchSuggestionsNotification");
          // Don't show the one-off buttons if we are showing onboarding and
          // there's no result, since it would be ugly and pointless.
          this.footer.collapsed = this.matchCount == 0;
          this.input.tabScrolling = this.matchCount != 0;

          // This event allows accessibility APIs to see the notification.
          if (!this.popupOpen) {
            let event = document.createEvent("Events");
            event.initEvent("AlertActive", true, true);
            this.searchSuggestionsNotification.dispatchEvent(event);
          }
          ]]>
        </body>
      </method>

      <method name="_hideSearchSuggestionsNotification">
        <body>
          <![CDATA[
          this.classList.remove("showSearchSuggestionsNotification");
          this.richlistbox.flex = 1;
          this.removeAttribute("dontanimate");
          this.searchSuggestionsNotification.removeAttribute("animate");
          if (this.matchCount) {
            // Update popup height.
            this._invalidate();
          } else {
            this.closePopup();
          }
          ]]>
        </body>
      </method>

      <method name="_selectedOneOffChanged">
        <body><![CDATA[
          // Update all searchengine result items to use the newly selected
          // engine.
          for (let item of this.richlistbox.childNodes) {
            if (item.collapsed) {
              break;
            }
            let url = item.getAttribute("url");
            if (url) {
              let action = item._parseActionUrl(url);
              if (action && action.type == "searchengine") {
                item._adjustAcItem();
              }
            }
          }
        ]]></body>
      </method>

      <!-- This handles keypress changes to the selection among the one-off
           search buttons and between the one-offs and the listbox.  It returns
           true if the keypress was consumed and false if not. -->
      <method name="handleKeyPress">
        <parameter name="aEvent"/>
        <body><![CDATA[
          this.oneOffSearchButtons.handleKeyPress(aEvent, this.matchCount,
                                                  !this._isFirstResultHeuristic,
                                                  gBrowser.userTypedValue);
          return aEvent.defaultPrevented && !aEvent.urlbarDeferred;
        ]]></body>
      </method>

      <!-- This is called when a one-off is clicked and when "search in new tab"
           is selected from a one-off context menu. -->
      <method name="handleOneOffSearch">
        <parameter name="event"/>
        <parameter name="engine"/>
        <parameter name="where"/>
        <parameter name="params"/>
        <body><![CDATA[
          this.input.handleCommand(event, where, params);
        ]]></body>
      </method>

      <!-- Result listitems call this to determine which search engine they
           should show in their labels and include in their url attributes. -->
      <property name="overrideSearchEngineName" readonly="true">
        <getter><![CDATA[
          let button = this.oneOffSearchButtons.selectedButton;
          return button && button.engine && button.engine.name;
        ]]></getter>
      </property>

      <method name="createResultLabel">
        <parameter name="item"/>
        <parameter name="proposedLabel"/>
        <body>
          <![CDATA[
            let parts = [proposedLabel];

            let action = this.mInput._parseActionUrl(item.getAttribute("url"));
            if (action) {
              switch (action.type) {
              case "searchengine":
                parts = [
                  action.params.searchSuggestion || action.params.searchQuery,
                  action.params.engineName,
                ];
                break;
              case "switchtab":
              case "remotetab":
                parts = [
                  item.getAttribute("title"),
                  item.getAttribute("displayurl"),
                ];
                break;
              }
            }

            let types = item.getAttribute("type").split(/\s+/);
            let type = types.find(t => t != "action" && t != "heuristic");
            try {
              // Some types intentionally do not map to strings, which is not
              // an error.
              parts.push(this._bundle.GetStringFromName(type + "ResultLabel"));
            } catch (e) {}

            return parts.filter(str => str).join(" ");
          ]]>
        </body>
      </method>

      <method name="maybeSetupSpeculativeConnect">
        <parameter name="aUriString"/>
        <body><![CDATA[
          try {
            let uri = makeURI(aUriString);
            Services.io.speculativeConnect2(uri, gBrowser.contentPrincipal, null);
          } catch (ex) {
            // Can't setup speculative connection for this uri string for some
            // reason, just ignore it.
          }
        ]]></body>
      </method>

      <method name="onResultsAdded">
        <body>
          <![CDATA[
            // If nothing is selected yet, select the first result if it is a
            // pre-selected "heuristic" result.  (See UnifiedComplete.js.)
            if (this.selectedIndex == -1 && this._isFirstResultHeuristic) {
              // Don't fire DOMMenuItemActive so that screen readers still see
              // the input as being focused.
              this.richlistbox.suppressMenuItemEvent = true;
              this.input.controller.setInitiallySelectedIndex(0);
              this.richlistbox.suppressMenuItemEvent = false;
            }
            // If this is the first time we get the result from the current
            // search and we are not in the private context, we can speculatively
            // connect to the intended site as a performance optimization.
            if (!this.input.gotResultForCurrentQuery &&
                this.input.speculativeConnectEnabled &&
                !this.input.inPrivateContext &&
                this.input.mController.matchCount > 0) {
              let firstStyle = this.input.mController.getStyleAt(0);
              if (firstStyle.includes("autofill")) {
                let uri = this.input.mController.getFinalCompleteValueAt(0);
                // "http" will be stripped out, but other scheme won't.
                if (!uri.includes("://")) {
                  uri = "http://" + uri;
                }
                this.maybeSetupSpeculativeConnect(uri);
              } else if (firstStyle.includes("searchengine") &&
                         this.input.browserSearchSuggestEnabled &&
                         this.input.urlbarSearchSuggestEnabled) {
                // Preconnect to the current search engine only if the search
                // suggestions are enabled.
                let engine = Services.search.currentEngine;
                engine.speculativeConnect({window,
                                           originAttributes: gBrowser.contentPrincipal.originAttributes});
              }
            }

            // When a result is present the footer should always be visible.
            this.footer.collapsed = false;
            this.input.tabScrolling = true;

            this.input.gotResultForCurrentQuery = true;
            this.input.replaySafeDeferredKeyEvents();
          ]]>
        </body>
      </method>

      <method name="_onSearchBegin">
        <body><![CDATA[
          // Set the selected index to 0 (heuristic) until a result comes back
          // and we can evaluate it better.
          //
          // This is required to properly manage delayed handleEnter:
          // 1. if a search starts we set selectedIndex to 0 here, and it will
          //    be updated by onResultsAdded. Since selectedIndex is 0,
          //    handleEnter will delay the action if a result didn't arrive yet.
          // 2. if a search doesn't start (for example if autocomplete is
          //    disabled), this won't be called, and the selectedIndex will be
          //    the default -1 value. Then handleEnter will know it should not
          //    delay the action, cause a result wont't ever arrive.
          this.input.controller.setInitiallySelectedIndex(0);

          // Since we are starting a new search, reset the currently selected
          // one-off button, to cover those cases where the oneoff buttons
          // binding won't receive an actual DOM event. For example, a search
          // could be started without an actual input event, and the popup may
          // not have been closed from the previous search.
          this.oneOffSearchButtons.selectedButton = null;
        ]]></body>
      </method>

      <field name="_addonIframe">null</field>
      <field name="_addonIframeOwner">null</field>
      <field name="_addonIframeOverriddenFunctionsByName">{}</field>

      <!-- These methods must be overridden and properly handled by the API
           runtime so that it doesn't break the popup.  If any of these methods
           is not overridden, then initAddonIframe should throw. -->
      <field name="_addonIframeOverrideFunctionNames">[
        "_invalidate",
      ]</field>

      <field name="_addonIframeHiddenAnonids">[
        "search-suggestions-notification",
        "richlistbox",
        "one-off-search-buttons",
      ]</field>
      <field name="_addonIframeHiddenDisplaysByAnonid">{}</field>

      <method name="initAddonIframe">
        <parameter name="owner"/>
        <parameter name="overrides"/>
        <body><![CDATA[
          if (this._addonIframeOwner) {
            // Another add-on has already requested the iframe.  Return null to
            // signal to the calling add-on that it should not take over the
            // popup.  First add-on wins for now.
            return null;
          }
          // Make sure all overrides are provided before doing anything.
          for (let name of this._addonIframeOverrideFunctionNames) {
            if (typeof(overrides[name]) != "function") {
              throw new Error(
                "Override for method '" + name + "' must be given"
              );
            }
          }
          // OK, insert the iframe.
          this._addonIframeOwner = owner;
          this._addonIframe = this._makeAddonIframe();
          this._addonIframeOverriddenFunctionsByName = {};
          for (let name of this._addonIframeOverrideFunctionNames) {
            this._addonIframeOverriddenFunctionsByName[name] = this[name];
            this[name] = overrides[name];
          }
          return this._addonIframe;
        ]]></body>
      </method>

      <method name="destroyAddonIframe">
        <parameter name="owner"/>
        <body><![CDATA[
          if (this._addonIframeOwner != owner) {
            throw new Error("You're not the iframe owner");
          }
          this._addonIframeOwner = null;
          this._addonIframe.remove();
          this._addonIframe = null;
          for (let anonid of this._addonIframeHiddenAnonids) {
            let child = document.getAnonymousElementByAttribute(
              this, "anonid", anonid
            );
            child.style.display =
              this._addonIframeHiddenDisplaysByAnonid[anonid];
          }
          for (let name in this._addonIframeOverriddenFunctionsByName) {
            this[name] = this._addonIframeOverriddenFunctionsByName[name];
          }
          this._addonIframeOverriddenFunctionsByName = {};
        ]]></body>
      </method>

      <method name="_makeAddonIframe">
        <body><![CDATA[
          this._addonIframeHiddenDisplaysByAnonid = {};
          for (let anonid of this._addonIframeHiddenAnonids) {
            let child = document.getAnonymousElementByAttribute(
              this, "anonid", anonid
            );
            this._addonIframeHiddenDisplaysByAnonid[anonid] =
              child.style.display;
            child.style.display = "none";
          }
          let XUL_NS =
            "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
          let iframe = document.createElementNS(XUL_NS, "iframe");
          iframe.setAttribute("type", "content");
          iframe.setAttribute("flex", "1");
          iframe.style.transition = "height 100ms";
          this.appendChild(iframe);
          return iframe;
        ]]></body>
      </method>

    </implementation>
    <handlers>

      <handler event="SelectedOneOffButtonChanged"><![CDATA[
        this._selectedOneOffChanged();
      ]]></handler>

      <handler event="mousedown"><![CDATA[
        // Required to make the xul:label.text-link elements in the search
        // suggestions notification work correctly when clicked on Linux.
        // This is copied from the mousedown handler in
        // browser-search-autocomplete-result-popup, which apparently had a
        // similar problem.
        event.preventDefault();

        if (!this.input.speculativeConnectEnabled) {
          return;
        }
        if (event.button == 2) {
          // Ignore right-clicks.
          return;
        }
        // Ensure the user is clicking on an url instead of other buttons
        // on the popup.
        let elt = event.originalTarget;
        while (elt && elt.localName != "richlistitem" && elt != this) {
          elt = elt.parentNode;
        }
        if (!elt || elt.localName != "richlistitem") {
          return;
        }
        // The user might click on a ghost entry which was removed because of
        // the coming new results.
        if (this.input.controller.matchCount <= this.selectedIndex) {
          return;
        }

        let url = this.input.controller.getFinalCompleteValueAt(this.selectedIndex);

        // Whitelist the cases that we want to speculative connect, and ignore
        // other moz-action uris or fancy protocols.
        // Note that it's likely we've speculatively connected to the first
        // url because it is a heuristic "autofill" result (see bug 1348275).
        // "moz-action:searchengine" is also the same case. (see bug 1355443)
        // So we won't duplicate the effort here.
        if (url.startsWith("http") && this.selectedIndex > 0) {
          this.maybeSetupSpeculativeConnect(url);
        } else if (url.startsWith("moz-action:remotetab")) {
          // URL is in the format moz-action:ACTION,PARAMS
          // Where PARAMS is a JSON encoded object.
          const MOZ_ACTION_REGEX = /^moz-action:([^,]+),(.*)$/;
          if (!MOZ_ACTION_REGEX.test(url))
            return;

          let params = JSON.parse(url.match(MOZ_ACTION_REGEX)[2]);
          if (params.url) {
            this.maybeSetupSpeculativeConnect(decodeURIComponent(params.url));
          }
        }

      ]]></handler>

    </handlers>
  </binding>

  <binding id="autocomplete-richlistitem" extends="chrome://global/content/bindings/richlistbox.xml#richlistitem">

    <content align="start"
             onoverflow="this._onOverflow();"
             onunderflow="this._onUnderflow();">

	  <xul:image anonid="type-icon"
                 class="ac-type-icon"
                 xbl:inherits="selected,current,type"/>
      <xul:image anonid="site-icon"
                 class="ac-site-icon"
                 xbl:inherits="src=image,selected,type"/>
      <xul:hbox class="ac-title"
                align="center"
                xbl:inherits="selected">
        <xul:description class="ac-text-overflow-container">
          <xul:description anonid="title-text"
                           class="ac-title-text"
                           xbl:inherits="selected"/>
        </xul:description>

	  </xul:hbox>
	  
      <xul:hbox anonid="tags"
                class="ac-tags"
                align="center"
                xbl:inherits="selected">
        <xul:description class="ac-text-overflow-container">
          <xul:description anonid="tags-text"
                           class="ac-tags-text"
                           xbl:inherits="selected"/>
        </xul:description>
      </xul:hbox>
	  
      <xul:hbox anonid="separator"
                class="ac-separator"
                align="center"
                xbl:inherits="selected,actiontype,type">
        <xul:description class="ac-separator-text">â€”</xul:description>
      </xul:hbox>
      <xul:hbox class="ac-url"
                align="center"
                xbl:inherits="selected,actiontype">
        <xul:description class="ac-text-overflow-container">
          <xul:description anonid="url-text"
                           class="ac-url-text"
                           xbl:inherits="selected"/>
        </xul:description>
      </xul:hbox>
      <xul:hbox class="ac-action"
                align="center"
                xbl:inherits="selected,actiontype">
        <xul:description class="ac-text-overflow-container">
          <xul:description anonid="action-text"
                           class="ac-action-text"
                           xbl:inherits="selected"/>
        </xul:description>
      </xul:hbox>

    </content>
	
    <implementation implements="nsIDOMXULSelectControlItemElement">
      <constructor>
        <![CDATA[
          this._typeIcon = document.getAnonymousElementByAttribute(
            this, "anonid", "type-icon"
          );
          this._siteIcon = document.getAnonymousElementByAttribute(
            this, "anonid", "site-icon"
          );
          this._titleText = document.getAnonymousElementByAttribute(
            this, "anonid", "title-text"
          );
          this._tags = document.getAnonymousElementByAttribute(
            this, "anonid", "tags"
          );
          this._tagsText = document.getAnonymousElementByAttribute(
            this, "anonid", "tags-text"
          );
          this._separator = document.getAnonymousElementByAttribute(
            this, "anonid", "separator"
          );
          this._urlText = document.getAnonymousElementByAttribute(
            this, "anonid", "url-text"
          );
          this._actionText = document.getAnonymousElementByAttribute(
            this, "anonid", "action-text"
          );
          this._adjustAcItem();
        ]]>
      </constructor>

      <method name="_cleanup">
        <body>
        <![CDATA[
          this.removeAttribute("url");
          this.removeAttribute("image");
          this.removeAttribute("title");
          this.removeAttribute("text");
          this.removeAttribute("displayurl");
        ]]>
        </body>
      </method>

      <property name="label" readonly="true">
        <getter>
          <![CDATA[
            // This property is a string that is read aloud by screen readers,
            // so it must not contain anything that should not be user-facing.

            let parts = [
              this.getAttribute("title"),
              this.getAttribute("displayurl"),
            ];
            let label = parts.filter(str => str).join(" ");

            // allow consumers that have extended popups to override
            // the label values for the richlistitems
            let panel = this.parentNode.parentNode;
            if (panel.createResultLabel) {
              return panel.createResultLabel(this, label);
            }

            return label;
          ]]>
        </getter>
      </property>

      <property name="_stringBundle">
        <getter><![CDATA[
          if (!this.__stringBundle) {
            this.__stringBundle = Services.strings.createBundle("chrome://global/locale/autocomplete.properties");
          }
          return this.__stringBundle;
        ]]></getter>
      </property>

      <field name="_boundaryCutoff">null</field>

      <property name="boundaryCutoff" readonly="true">
        <getter>
          <![CDATA[
          if (!this._boundaryCutoff) {
            this._boundaryCutoff =
              Components.classes["@mozilla.org/preferences-service;1"].
              getService(Components.interfaces.nsIPrefBranch).
              getIntPref("toolkit.autocomplete.richBoundaryCutoff");
          }
          return this._boundaryCutoff;
          ]]>
        </getter>
      </property>

      <field name="_inOverflow">false</field>

      <method name="_onOverflow">
        <body>
          <![CDATA[
          this._inOverflow = true;
          this._handleOverflow();
          ]]>
        </body>
      </method>

      <method name="_onUnderflow">
        <body>
          <![CDATA[
          this._inOverflow = false;
          this._handleOverflow();
          ]]>
        </body>
      </method>

      <method name="_getBoundaryIndices">
        <parameter name="aText"/>
        <parameter name="aSearchTokens"/>
        <body>
          <![CDATA[
          // Short circuit for empty search ([""] == "")
          if (aSearchTokens == "")
            return [0, aText.length];

          // Find which regions of text match the search terms
          let regions = [];
          for (let search of Array.prototype.slice.call(aSearchTokens)) {
            let matchIndex = -1;
            let searchLen = search.length;

            // Find all matches of the search terms, but stop early for perf
            let lowerText = aText.substr(0, this.boundaryCutoff).toLowerCase();
            while ((matchIndex = lowerText.indexOf(search, matchIndex + 1)) >= 0) {
              regions.push([matchIndex, matchIndex + searchLen]);
            }
          }

          // Sort the regions by start position then end position
          regions = regions.sort((a, b) => {
            let start = a[0] - b[0];
            return (start == 0) ? a[1] - b[1] : start;
          });

          // Generate the boundary indices from each region
          let start = 0;
          let end = 0;
          let boundaries = [];
          let len = regions.length;
          for (let i = 0; i < len; i++) {
            // We have a new boundary if the start of the next is past the end
            let region = regions[i];
            if (region[0] > end) {
              // First index is the beginning of match
              boundaries.push(start);
              // Second index is the beginning of non-match
              boundaries.push(end);

              // Track the new region now that we've stored the previous one
              start = region[0];
            }

            // Push back the end index for the current or new region
            end = Math.max(end, region[1]);
          }

          // Add the last region
          boundaries.push(start);
          boundaries.push(end);

          // Put on the end boundary if necessary
          if (end < aText.length)
            boundaries.push(aText.length);

          // Skip the first item because it's always 0
          return boundaries.slice(1);
          ]]>
        </body>
      </method>

      <method name="_getSearchTokens">
        <parameter name="aSearch"/>
        <body>
          <![CDATA[
          let search = aSearch.toLowerCase();
          return search.split(/\s+/);
          ]]>
        </body>
      </method>

      <method name="_setUpDescription">
        <parameter name="aDescriptionElement"/>
        <parameter name="aText"/>
        <parameter name="aNoEmphasis"/>
        <body>
          <![CDATA[
          // Get rid of all previous text
          if (!aDescriptionElement) {
            return;
          }
          while (aDescriptionElement.hasChildNodes())
            aDescriptionElement.firstChild.remove();

          // If aNoEmphasis is specified, don't add any emphasis
          if (aNoEmphasis) {
            aDescriptionElement.appendChild(document.createTextNode(aText));
            return;
          }

          // Get the indices that separate match and non-match text
          let search = this.getAttribute("text");
          let tokens = this._getSearchTokens(search);
          let indices = this._getBoundaryIndices(aText, tokens);

          this._appendDescriptionSpans(indices, aText, aDescriptionElement,
                                       aDescriptionElement);
          ]]>
        </body>
      </method>

      <method name="_appendDescriptionSpans">
        <parameter name="indices"/>
        <parameter name="text"/>
        <parameter name="spansParentElement"/>
        <parameter name="descriptionElement"/>
        <body>
          <![CDATA[
          let next;
          let start = 0;
          let len = indices.length;
          // Even indexed boundaries are matches, so skip the 0th if it's empty
          for (let i = indices[0] == 0 ? 1 : 0; i < len; i++) {
            next = indices[i];
            let spanText = text.substr(start, next - start);
            start = next;

            if (i % 2 == 0) {
              // Emphasize the text for even indices
              let span = spansParentElement.appendChild(
                document.createElementNS("http://www.w3.org/1999/xhtml", "span"));
              this._setUpEmphasisSpan(span, descriptionElement);
              span.textContent = spanText;
            } else {
              // Otherwise, it's plain text
              spansParentElement.appendChild(document.createTextNode(spanText));
            }
          }
          ]]>
        </body>
      </method>

      <method name="_setUpTags">
        <parameter name="tags"/>
        <body>
          <![CDATA[
          while (this._tagsText.hasChildNodes()) {
            this._tagsText.firstChild.remove();
          }

          let anyTagsMatch = false;

          // Include only tags that match the search string.
          for (let tag of tags) {
            // Check if the tag matches the search string.
            let search = this.getAttribute("text");
            let tokens = this._getSearchTokens(search);
            let indices = this._getBoundaryIndices(tag, tokens);

            if (indices.length == 2 &&
                indices[0] == 0 &&
                indices[1] == tag.length) {
              // The tag doesn't match the search string, so don't include it.
              continue;
            }

            anyTagsMatch = true;

            let tagSpan =
              document.createElementNS("http://www.w3.org/1999/xhtml", "span");
            tagSpan.classList.add("ac-tag");
            this._tagsText.appendChild(tagSpan);

            this._appendDescriptionSpans(indices, tag, tagSpan, this._tagsText);
          }

          return anyTagsMatch;
          ]]>
        </body>
      </method>

      <method name="_setUpEmphasisSpan">
        <parameter name="aSpan"/>
        <parameter name="aDescriptionElement"/>
        <body>
          <![CDATA[
          aSpan.classList.add("ac-emphasize-text");
          switch (aDescriptionElement) {
            case this._titleText:
              aSpan.classList.add("ac-emphasize-text-title");
              break;
            case this._tagsText:
              aSpan.classList.add("ac-emphasize-text-tag");
              break;
            case this._urlText:
              aSpan.classList.add("ac-emphasize-text-url");
              break;
            case this._actionText:
              aSpan.classList.add("ac-emphasize-text-action");
              break;
          }
          ]]>
        </body>
      </method>

      <!--
        This will generate an array of emphasis pairs for use with
        _setUpEmphasisedSections(). Each pair is a tuple (array) that
        represents a block of text - containing the text of that block, and a
        boolean for whether that block should have an emphasis styling applied
        to it.

        These pairs are generated by parsing a localised string (aSourceString)
        with parameters, in the format that is used by
        nsIStringBundle.formatStringFromName():

          "textA %1$S textB textC %2$S"

        Or:

          "textA %S"

        Where "%1$S", "%2$S", and "%S" are intended to be replaced by provided
        replacement strings. These are specified an array of tuples
        (aReplacements), each containing the replacement text and a boolean for
        whether that text should have an emphasis styling applied. This is used
        as a 1-based array - ie, "%1$S" is replaced by the item in the first
        index of aReplacements, "%2$S" by the second, etc. "%S" will always
        match the first index.
      -->
      <method name="_generateEmphasisPairs">
        <parameter name="aSourceString"/>
        <parameter name="aReplacements"/>
        <body>
          <![CDATA[
            let pairs = [];

            // Split on %S, %1$S, %2$S, etc. ie:
            //   "textA %S"
            //     becomes ["textA ", "%S"]
            //   "textA %1$S textB textC %2$S"
            //     becomes ["textA ", "%1$S", " textB textC ", "%2$S"]
            let parts = aSourceString.split(/(%(?:[0-9]+\$)?S)/);

            for (let part of parts) {
              // The above regex will actually give us an empty string at the
              // end - we don't want that, as we don't want to later generate an
              // empty text node for it.
              if (part.length === 0)
                continue;

              // Determine if this token is a replacement token or a normal text
              // token. If it is a replacement token, we want to extract the
              // numerical number. However, we still want to match on "$S".
              let match = part.match(/^%(?:([0-9]+)\$)?S$/);

              if (match) {
                // "%S" doesn't have a numerical number in it, but will always
                // be assumed to be 1. Furthermore, the input string specifies
                // these with a 1-based index, but we want a 0-based index.
                let index = (match[1] || 1) - 1;

                if (index >= 0 && index < aReplacements.length) {
                  pairs.push([...aReplacements[index]]);
                }
              } else {
                pairs.push([part]);
              }
            }

            return pairs;
          ]]>
        </body>
      </method>

      <!--
        _setUpEmphasisedSections() has the same use as _setUpDescription,
        except instead of taking a string and highlighting given tokens, it takes
        an array of pairs generated by _generateEmphasisPairs(). This allows
        control over emphasising based on specific blocks of text, rather than
        search for substrings.
      -->
      <method name="_setUpEmphasisedSections">
        <parameter name="aDescriptionElement"/>
        <parameter name="aTextPairs"/>
        <body>
          <![CDATA[
          // Get rid of all previous text
          while (aDescriptionElement.hasChildNodes())
            aDescriptionElement.firstChild.remove();

          for (let [text, emphasise] of aTextPairs) {
            if (emphasise) {
              let span = aDescriptionElement.appendChild(
                document.createElementNS("http://www.w3.org/1999/xhtml", "span"));
              span.textContent = text;
              switch (emphasise) {
                case "match":
                  this._setUpEmphasisSpan(span, aDescriptionElement);
                  break;
              }
            } else {
              aDescriptionElement.appendChild(document.createTextNode(text));
            }
          }
          ]]>
        </body>
      </method>

      <method name="_unescapeUrl">
        <parameter name="url"/>
        <body>
          <![CDATA[
          return Services.textToSubURI.unEscapeURIForUI("UTF-8", url);
          ]]>
        </body>
      </method>

      <method name="_reuseAcItem">
        <body>
          <![CDATA[
            let action = this._parseActionUrl(this.getAttribute("url"));
            let popup = this.parentNode.parentNode;

            // If the item is a searchengine action, then it should
            // only be reused if the engine name is the same as the
            // popup's override engine name, if any.
            if (!action ||
                action.type != "searchengine" ||
                !popup.overrideSearchEngineName ||
                action.params.engineName == popup.overrideSearchEngineName) {

              this.collapsed = false;

              // The popup may have changed size between now and the last
              // time the item was shown, so always handle over/underflow.
              let dwu = window.getInterface(Ci.nsIDOMWindowUtils);
              let popupWidth = dwu.getBoundsWithoutFlushing(this.parentNode).width;
              if (!this._previousPopupWidth || this._previousPopupWidth != popupWidth) {
                this._previousPopupWidth = popupWidth;
                this.handleOverUnderflow();
              }

              return true;
            }

            return false;
          ]]>
        </body>
      </method>


      <method name="_adjustAcItem">
        <body>
          <![CDATA[
          let originalUrl = this.getAttribute("ac-value");
          let title = this.getAttribute("ac-comment");
          this.setAttribute("url", originalUrl);
          this.setAttribute("image", this.getAttribute("ac-image"));
          this.setAttribute("title", title);
          this.setAttribute("text", this.getAttribute("ac-text"));

          let popup = this.parentNode.parentNode;
          let titleLooksLikeUrl = false;
          let displayUrl;
          let emphasiseUrl = true;

          let type = this.getAttribute("originaltype");
          let types = new Set(type.split(/\s+/));
          let initialTypes = new Set(types);
          // Remove types that should ultimately not be in the `type` string.
          types.delete("action");
          types.delete("autofill");
          types.delete("heuristic");
          type = [...types][0] || "";

          let action;

          if (initialTypes.has("autofill")) {
            // Treat autofills as visiturl actions.
            action = {
              type: "visiturl",
              params: {
                url: this.getAttribute("title"),
              },
            };
          }

          this.removeAttribute("actiontype");
          this.classList.remove("overridable-action");

          // If the type includes an action, set up the item appropriately.
          if (initialTypes.has("action") || action) {
            action = action || this._parseActionUrl(originalUrl);
            this.setAttribute("actiontype", action.type);

            if (action.type == "switchtab") {
              this.classList.add("overridable-action");
              displayUrl = this._unescapeUrl(action.params.url);
              let desc = this._stringBundle.GetStringFromName("switchToTab2");
              this._setUpDescription(this._actionText, desc, true);
            } else if (action.type == "remotetab") {
              displayUrl = this._unescapeUrl(action.params.url);
              let desc = action.params.deviceName;
              this._setUpDescription(this._actionText, desc, true);
            } else if (action.type == "searchengine") {
              emphasiseUrl = false;

              // The order here is not localizable, we default to appending
              // "- Search with Engine" to the search string, to be able to
              // properly generate emphasis pairs. That said, no localization
              // changed the order while it was possible, so doesn't look like
              // there's a strong need for that.
              let {engineName, searchSuggestion, searchQuery} = action.params;

              // Override the engine name if the popup defines an override.
              let override = popup.overrideSearchEngineName;
              if (override && override != engineName) {
                engineName = override;
                action.params.engineName = override;
                let newURL =
                  PlacesUtils.mozActionURI(action.type, action.params);
                this.setAttribute("url", newURL);
              }

              let engineStr =
                this._stringBundle.formatStringFromName("searchWithEngine",
                                                        [engineName], 1);
              this._setUpDescription(this._actionText, engineStr, true);

              // Make the title by generating an array of pairs and its
              // corresponding interpolation string (e.g., "%1$S") to pass to
              // _generateEmphasisPairs.
              let pairs;
              if (searchSuggestion) {
                // Check if the search query appears in the suggestion.  It may
                // not.  If it does, then emphasize the query in the suggestion
                // and otherwise just include the suggestion without emphasis.
                let idx = searchSuggestion.indexOf(searchQuery);
                if (idx >= 0) {
                  pairs = [
                    [searchSuggestion.substring(0, idx), ""],
                    [searchQuery, "match"],
                    [searchSuggestion.substring(idx + searchQuery.length), ""],
                  ];
                } else {
                  pairs = [
                    [searchSuggestion, ""],
                  ];
                }
              } else {
                pairs = [
                  [searchQuery, ""],
                ];
              }
              let interpStr = pairs.map((pair, i) => `%${i + 1}$S`).join("");
              title = this._generateEmphasisPairs(interpStr, pairs);

              // If this is a default search match, we remove the image so we
              // can style it ourselves with a generic search icon.
              // We don't do this when matching an aliased search engine,
              // because the icon helps with recognising which engine will be
              // used (when using the default engine, we don't need that
              // recognition).
              if (!action.params.alias && !initialTypes.has("favicon")) {
                this.removeAttribute("image");
              }
            } else if (action.type == "visiturl") {
              emphasiseUrl = false;
              displayUrl = this._unescapeUrl(action.params.url);
              title = displayUrl;
              titleLooksLikeUrl = true;
              let visitStr = this._stringBundle.GetStringFromName("visit");
              this._setUpDescription(this._actionText, visitStr, true);
            } else if (action.type == "extension") {
              let content = action.params.content;
              displayUrl = content;
              this._setUpDescription(this._actionText, content, true);
            }
          }

          if (!displayUrl) {
            let input = popup.input;
            let url = typeof(input.trimValue) == "function" ?
                      input.trimValue(originalUrl) :
                      originalUrl;
            displayUrl = this._unescapeUrl(url);
          }
          // For performance reasons we may want to limit the displayUrl size.
          if (popup.textRunsMaxLen) {
            displayUrl = displayUrl.substr(0, popup.textRunsMaxLen);
          }
          this.setAttribute("displayurl", displayUrl);

          // Show the domain as the title if we don't have a title.
          if (!title) {
            title = displayUrl;
            titleLooksLikeUrl = true;
            try {
              let uri = Services.io.newURI(originalUrl);
              // Not all valid URLs have a domain.
              if (uri.host)
                title = uri.host;
            } catch (e) {}
          }

          this._tags.setAttribute("empty", "true");

          if (type == "tag" || type == "bookmark-tag") {
            // The title is separated from the tags by an endash
            let tags;
            [, title, tags] = title.match(/^(.+) \u2013 (.+)$/);

            // Each tag is split by a comma in an undefined order, so sort it
            let sortedTags = tags.split(/\s*,\s*/).sort((a, b) => {
              return a.localeCompare(a);
            });

            let anyTagsMatch = this._setUpTags(sortedTags);
            if (anyTagsMatch) {
              this._tags.removeAttribute("empty");
            }
            if (type == "bookmark-tag") {
              type = "bookmark";
            }
          } else if (type == "keyword") {
            // Note that this is a moz-action with action.type == keyword.
            emphasiseUrl = false;
            let keywordArg = this.getAttribute("text").replace(/^[^\s]+\s*/, "");
            if (!keywordArg) {
              // Treat keyword searches without arguments as visiturl actions.
              type = "visiturl";
              this.setAttribute("actiontype", "visiturl");
              let visitStr = this._stringBundle.GetStringFromName("visit");
              this._setUpDescription(this._actionText, visitStr, true);
            } else {
              let pairs = [[title, ""], [keywordArg, "match"]];
              let interpStr =
                this._stringBundle.GetStringFromName("bookmarkKeywordSearch");
              title = this._generateEmphasisPairs(interpStr, pairs);
              // The action box will be visible since this is a moz-action, but
              // we want it to appear as if it were not visible, so set its text
              // to the empty string.
              this._setUpDescription(this._actionText, "", false);
            }
          }

          this.setAttribute("type", type);

          if (titleLooksLikeUrl) {
            this._titleText.setAttribute("lookslikeurl", "true");
          } else {
            this._titleText.removeAttribute("lookslikeurl");
          }

          if (Array.isArray(title)) {
            // For performance reasons we may want to limit the title size.
            if (popup.textRunsMaxLen) {
              title = title.map(t => t.substr(0, popup.textRunsMaxLen));
            }
            this._setUpEmphasisedSections(this._titleText, title);
          } else {
            // For performance reasons we may want to limit the title size.
            if (popup.textRunsMaxLen) {
              title = title.substr(0, popup.textRunsMaxLen);
            }
            this._setUpDescription(this._titleText, title, false);
          }
          this._setUpDescription(this._urlText, displayUrl, !emphasiseUrl);

          // Removing the max-width may be jarring when the item is visible, but
          // we have no other choice to properly crop the text.
          // Removing max-widths may cause overflow or underflow events, that
          // will set the _inOverflow property. In case both the old and the new
          // text are overflowing, the overflow event won't happen, and we must
          // enforce an _handleOverflow() call to update the max-widths.
          let wasInOverflow = this._inOverflow;
          this._removeMaxWidths();
          if (wasInOverflow && this._inOverflow) {
            this._handleOverflow();
          }
          ]]>
        </body>
      </method>

      <method name="_removeMaxWidths">
        <body>
          <![CDATA[
          if (this._hasMaxWidths) {
            this._titleText.style.removeProperty("max-width");
            this._tagsText.style.removeProperty("max-width");
            this._urlText.style.removeProperty("max-width");
            this._actionText.style.removeProperty("max-width");
            this._hasMaxWidths = false;
          }
          ]]>
        </body>
      </method>

      <!-- This method truncates the displayed strings as necessary. -->
      <method name="_handleOverflow">
        <body><![CDATA[
          let itemRect = this.parentNode.getBoundingClientRect();
          let titleRect = this._titleText.getBoundingClientRect();
          let tagsRect = this._tagsText.getBoundingClientRect();
          let separatorRect = this._separator.getBoundingClientRect();
          let urlRect = this._urlText.getBoundingClientRect();
          let actionRect = this._actionText.getBoundingClientRect();
          let separatorURLActionWidth =
            separatorRect.width + Math.max(urlRect.width, actionRect.width);

          // Total width for the title and URL/action is the width of the item
          // minus the start of the title text minus a little optional extra padding.
          // This extra padding amount is basically arbitrary but keeps the text
          // from getting too close to the popup's edge.
          let dir = this.getAttribute("dir");
          let titleStart = dir == "rtl" ? itemRect.right - titleRect.right
                                        : titleRect.left - itemRect.left;

          let popup = this.parentNode.parentNode;
          /*let itemWidth = itemRect.width - titleStart - popup.overflowPadding -
                          (popup.margins ? popup.margins.end : 0);*/
		  let itemWidth = itemRect.width;

          if (this._tags.hasAttribute("empty")) {
            // The tags box is not displayed in this case.
            tagsRect.width = 0;
          }

          let titleTagsWidth = titleRect.width + tagsRect.width;
          if (titleTagsWidth + separatorURLActionWidth > itemWidth) {
            // Title + tags + URL/action overflows the item width.

            // The percentage of the item width allocated to the title and tags.
            let titleTagsPct = 0.66;

            let titleTagsAvailable = itemWidth - separatorURLActionWidth;
            let titleTagsMaxWidth = Math.max(
              titleTagsAvailable,
              itemWidth * titleTagsPct
            );
            if (titleTagsWidth > titleTagsMaxWidth) {
              // Title + tags overflows the max title + tags width.

              // The percentage of the title + tags width allocated to the
              // title.
              let titlePct = 0.33;

              let titleAvailable = titleTagsMaxWidth - tagsRect.width;
              let titleMaxWidth = Math.max(
                titleAvailable,
                titleTagsMaxWidth * titlePct
              );
              let tagsAvailable = titleTagsMaxWidth - titleRect.width;
              let tagsMaxWidth = Math.max(
                tagsAvailable,
                titleTagsMaxWidth * (1 - titlePct)
              );
              this._titleText.style.maxWidth = titleMaxWidth + "px";
              this._tagsText.style.maxWidth = tagsMaxWidth + "px";
            }
            let urlActionMaxWidth = Math.max(
              itemWidth - titleTagsWidth,
              itemWidth * (1 - titleTagsPct)
            );
            urlActionMaxWidth -= separatorRect.width;
            this._urlText.style.maxWidth = urlActionMaxWidth + "px";
            this._actionText.style.maxWidth = urlActionMaxWidth + "px";
            this._hasMaxWidths = true;
          }
        ]]></body>
      </method>

      <method name="handleOverUnderflow">
        <body>
          <![CDATA[
          this._removeMaxWidths();
          this._handleOverflow();
          ]]>
        </body>
      </method>

      <method name="_parseActionUrl">
        <parameter name="aUrl"/>
        <body><![CDATA[
          if (!aUrl.startsWith("moz-action:"))
            return null;

          // URL is in the format moz-action:ACTION,PARAMS
          // Where PARAMS is a JSON encoded object.
          let [, type, params] = aUrl.match(/^moz-action:([^,]+),(.*)$/);

          let action = {
            type,
          };

          try {
            action.params = JSON.parse(params);
            for (let key in action.params) {
              action.params[key] = decodeURIComponent(action.params[key]);
            }
          } catch (e) {
            // If this failed, we assume that params is not a JSON object, and
            // is instead just a flat string. This may happen for legacy
            // search components.
            action.params = {
              url: params,
            };
          }

          return action;
        ]]></body>
      </method>
    </implementation>

    <handlers>
      <!--
        This overrides listitem's mousedown handler because we want to set the
        selected item even when the shift or accel keys are pressed.
      -->
      <handler event="mousedown"><![CDATA[
        // Call this.control only once since it's not a simple getter.
        let control = this.control;
        if (!control || control.disabled) {
          return;
        }
        if (!this.selected) {
          control.selectItem(this);
        }
        control.currentItem = this;
      ]]></handler>

      <handler event="mouseover"><![CDATA[
        // The point of implementing this handler is to allow drags to change
        // the selected item.  If the user mouses down on an item, it becomes
        // selected.  If they then drag the mouse to another item, select it.
        // Handle all three primary mouse buttons: right, left, and wheel, since
        // all three change the selection on mousedown.
        let mouseDown = event.buttons & 0b111;
        if (!mouseDown) {
          return;
        }
        // Call this.control only once since it's not a simple getter.
        let control = this.control;
        if (!control || control.disabled) {
          return;
        }
        if (!this.selected) {
          control.selectItem(this);
        }
        control.currentItem = this;
      ]]></handler>
    </handlers>
  </binding>

</bindings>
