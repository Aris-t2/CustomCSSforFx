<?xml version="1.0"?>

<!--
** Modified Firefox 57+ bindings offered in ***********************************************
** chrome://global/content/bindings/autocomplete.xml#autocomplete-rich-result-popup *******
** and ************************************************************************************
** chrome://browser/content/urlbarBindings.xml#urlbar-rich-result-popup *******************
** to simulate pre-Fx48 look of location bars autocomplete popup and removed all default **
** default comments to reduce file size. **************************************************
-->

<!DOCTYPE bindings [
<!ENTITY % notificationDTD SYSTEM "chrome://global/locale/notification.dtd">
%notificationDTD;
<!ENTITY % browserDTD SYSTEM "chrome://browser/locale/browser.dtd">
%browserDTD;
<!ENTITY % brandDTD SYSTEM "chrome://branding/locale/brand.dtd">
%brandDTD;
]>

<bindings id="urlbarBindings"
		  xmlns="http://www.mozilla.org/xbl"
          xmlns:html="http://www.w3.org/1999/xhtml"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">

  <binding id="urlbar-rich-result-popup" extends="chrome://global/content/bindings/autocomplete.xml#autocomplete-rich-result-popup">

    <resources>
      <stylesheet src="chrome://browser/content/search/searchbarBindings.css"/>
      <stylesheet src="chrome://browser/skin/searchbar.css"/>
    </resources>

    <content ignorekeys="true" level="top" consumeoutsideclicks="never"
             aria-owns="richlistbox">
      <xul:deck anonid="search-suggestions-notification"
                align="center"
                role="alert"
                selectedIndex="0">

        <xul:hbox flex="1" align="center" anonid="search-suggestions-opt-out">
          <xul:image class="ac-site-icon" type="searchengine"/>
          <xul:hbox anonid="search-suggestions-hint-typing">
            <xul:description class="ac-title-text">&brandShortName;</xul:description>
          </xul:hbox>
          <xul:hbox anonid="search-suggestions-hint-box" flex="1">
            <xul:description id="search-suggestions-hint">
              <html:span class="prefix">&#x1f4a1; &urlbar.searchSuggestionsNotification.hintPrefix;</html:span>
              <html:span>&urlbar.searchSuggestionsNotification.hint;</html:span>
            </xul:description>
          </xul:hbox>
          <xul:label id="search-suggestions-change-settings"
                     class="text-link"
                     role="link"
                     value="&urlbar.searchSuggestionsNotification.changeSettingsWin;"
                     accesskey="&urlbar.searchSuggestionsNotification.changeSettingsWin.accesskey;"
                     onclick="openPreferences('paneSearch');"
                     control="search-suggestions-change-settings"/>
        </xul:hbox>
      </xul:deck>
      <xul:richlistbox anonid="richlistbox" class="autocomplete-richlistbox"
                       flex="1"/>
      <xul:hbox anonid="footer">
        <children/>
        <xul:vbox anonid="one-off-search-buttons"
                  class="search-one-offs"
                  compact="true"
                  includecurrentengine="true"
                  disabletab="true"
                  flex="1"/>
      </xul:hbox>
    </content>

    <implementation>
      <field name="DOMWindowUtils">
        window.QueryInterface(Ci.nsIInterfaceRequestor)
              .getInterface(Ci.nsIDOMWindowUtils);
      </field>

      <field name="_maxResults">0</field>

      <field name="_bundle" readonly="true">
        Cc["@mozilla.org/intl/stringbundle;1"].
          getService(Ci.nsIStringBundleService).
          createBundle("chrome://browser/locale/places/places.properties");
      </field>

      <field name="searchSuggestionsNotification" readonly="true">
        document.getAnonymousElementByAttribute(
          this, "anonid", "search-suggestions-notification"
        );
      </field>

      <field name="footer" readonly="true">
        document.getAnonymousElementByAttribute(this, "anonid", "footer");
      </field>

      <field name="oneOffSearchButtons" readonly="true">
        document.getAnonymousElementByAttribute(this, "anonid",
                                                "one-off-search-buttons");
      </field>

      <field name="_oneOffSearchesEnabled">false</field>

      <field name="_overrideValue">null</field>
      <property name="overrideValue"
                onget="return this._overrideValue;"
                onset="this._overrideValue = val; return val;"/>

      <method name="onPopupClick">
        <parameter name="aEvent"/>
        <body><![CDATA[
          if (aEvent.button == 2) {
            return;
          }
          let controller = this.view.QueryInterface(Components.interfaces.nsIAutoCompleteController);
          controller.handleEnter(true, aEvent);
        ]]></body>
      </method>

      <method name="enableOneOffSearches">
        <parameter name="enable"/>
        <body><![CDATA[
          this._oneOffSearchesEnabled = enable;
          if (enable) {
            this.oneOffSearchButtons.telemetryOrigin = "urlbar";
            this.oneOffSearchButtons.style.display = "-moz-box";
            this.oneOffSearchButtons.textbox = this.input;
            this.oneOffSearchButtons.popup = this;
          } else {
            this.oneOffSearchButtons.telemetryOrigin = null;
            this.oneOffSearchButtons.style.display = "none";
            this.oneOffSearchButtons.textbox = null;
            this.oneOffSearchButtons.popup = null;
          }
        ]]></body>
      </method>
      <method name="getNextIndex">
        <parameter name="reverse"/>
        <parameter name="amount"/>
        <parameter name="index"/>
        <parameter name="maxRow"/>
        <body><![CDATA[
          if (maxRow < 0)
            return -1;

          let newIndex = index + (reverse ? -1 : 1) * amount;

          if (!this._isFirstResultHeuristic) {
            if (reverse && index == -1 || newIndex > maxRow && index != maxRow)
              newIndex = maxRow;
            else if (!reverse && index == -1 || newIndex < 0 && index != 0)
              newIndex = 0;

            if (newIndex < 0 && index == 0 || newIndex > maxRow && index == maxRow)
              newIndex = -1;

            return newIndex;
          }

          if (newIndex < 0) {
            newIndex = index > 0 ? 0 : maxRow;
          } else if (newIndex > maxRow) {
            newIndex = index < maxRow ? maxRow : 0;
          }
          return newIndex;
        ]]></body>
      </method>

      <property name="_isFirstResultHeuristic" readonly="true">
        <getter>
          <![CDATA[
            return this.input.mController.matchCount > 0 &&
                   this.input.mController
                             .getStyleAt(0)
                             .split(/\s+/).indexOf("heuristic") > 0;
          ]]>
        </getter>
      </property>

      <property name="maxResults">
        <getter>
          <![CDATA[
            if (!this._maxResults) {
              this._maxResults = Services.prefs.getIntPref("browser.urlbar.maxRichResults");
            }
            return this._maxResults;
          ]]>
        </getter>
        <setter>
          <![CDATA[
            return this._maxResults = parseInt(val);
          ]]>
        </setter>
      </property>

      <method name="openAutocompletePopup">
        <parameter name="aInput"/>
        <parameter name="aElement"/>
        <body>
          <![CDATA[
          aInput.popup.hidden = false;

          this._openAutocompletePopup(aInput, aElement);
          ]]>
        </body>
      </method>

      <method name="_openAutocompletePopup">
        <parameter name="aInput"/>
        <parameter name="aElement"/>
        <body><![CDATA[
          if (this.mPopupOpen) {
            return;
          }
  
		  var width = 300;

		  try{
			width = Math.round(document.getElementById("urlbar").getBoundingClientRect().width);
		  } catch(e){}
		  
		  this.setAttribute("width", width);

          try {
            let whichNotification = aInput.whichSearchSuggestionsNotification;
            if (whichNotification != "none") {
              let impressionId = this._searchSuggestionsImpressionId = {};
              this.addEventListener("popupshown", () => {
                if (this._searchSuggestionsImpressionId == impressionId)
                  aInput.updateSearchSuggestionsNotificationImpressions(whichNotification);
              }, {once: true});
              this._showSearchSuggestionsNotification(whichNotification, popupDirection);
            } else if (this.classList.contains("showSearchSuggestionsNotification")) {
              this._hideSearchSuggestionsNotification();
            }
          } catch (ex) {

            Components.utils.reportError(ex);
          }

          this.openPopup(aElement, "after_start", 0, -1, false, false);
        ]]></body>
      </method>

      <method name="_showSearchSuggestionsNotification">
        <parameter name="whichNotification"/>
        <parameter name="popupDirection"/>
        <body>
          <![CDATA[
          if (whichNotification == "opt-out") {
            if (this.siteIconStart) {
              this.searchSuggestionsNotification.style.paddingInlineStart =
                this.siteIconStart + "px";
            } else {
              this.searchSuggestionsNotification.style.removeProperty("padding-inline-start");
            }

            if (!this._firstSearchSuggestionsNotification) {
              this._firstSearchSuggestionsNotification = true;
              this.searchSuggestionsNotification.setAttribute("animate", "true");
            }
          }

          this.searchSuggestionsNotification.setAttribute("aria-describedby",
                                                          "search-suggestions-hint");

          this.richlistbox.flex = 0;
          this.setAttribute("dontanimate", "true");

          this.classList.add("showSearchSuggestionsNotification");
          this.footer.collapsed = this._matchCount == 0;
          this.input.tabScrolling = this._matchCount != 0;

          if (!this.popupOpen) {
            let event = document.createEvent("Events");
            event.initEvent("AlertActive", true, true);
            this.searchSuggestionsNotification.dispatchEvent(event);
          }
          ]]>
        </body>
      </method>

      <method name="_hideSearchSuggestionsNotification">
        <body>
          <![CDATA[
          this.classList.remove("showSearchSuggestionsNotification");
          this.richlistbox.flex = 1;
          this.removeAttribute("dontanimate");
          this.searchSuggestionsNotification.removeAttribute("animate");
          if (this._matchCount) {
            this._invalidate();
          } else {
            this.closePopup();
          }
          ]]>
        </body>
      </method>

      <method name="_selectedOneOffChanged">
        <body><![CDATA[
          for (let item of this.richlistbox.childNodes) {
            if (item.collapsed) {
              break;
            }
            let url = item.getAttribute("url");
            if (url) {
              let action = item._parseActionUrl(url);
              if (action && action.type == "searchengine") {
                item._adjustAcItem();
              }
            }
          }
        ]]></body>
      </method>

      <method name="handleKeyPress">
        <parameter name="aEvent"/>
        <body><![CDATA[
          this.oneOffSearchButtons.handleKeyPress(aEvent, this._matchCount,
                                                  !this._isFirstResultHeuristic,
                                                  gBrowser.userTypedValue);
          return aEvent.defaultPrevented && !aEvent.urlbarDeferred;
        ]]></body>
      </method>

      <method name="handleOneOffSearch">
        <parameter name="event"/>
        <parameter name="engine"/>
        <parameter name="where"/>
        <parameter name="params"/>
        <body><![CDATA[
          this.input.handleCommand(event, where, params);
        ]]></body>
      </method>

      <property name="overrideSearchEngineName" readonly="true">
        <getter><![CDATA[
          let button = this.oneOffSearchButtons.selectedButton;
          return button && button.engine && button.engine.name;
        ]]></getter>
      </property>

      <method name="createResultLabel">
        <parameter name="item"/>
        <parameter name="proposedLabel"/>
        <body>
          <![CDATA[
            let parts = [proposedLabel];

            let action = this.mInput._parseActionUrl(item.getAttribute("url"));
            if (action) {
              switch (action.type) {
              case "searchengine":
                parts = [
                  action.params.searchSuggestion || action.params.searchQuery,
                  action.params.engineName,
                ];
                break;
              case "switchtab":
              case "remotetab":
                parts = [
                  item.getAttribute("title"),
                  item.getAttribute("displayurl"),
                ];
                break;
              }
            }

            let types = item.getAttribute("type").split(/\s+/);
            let type = types.find(t => t != "action" && t != "heuristic");
            try {
              parts.push(this._bundle.GetStringFromName(type + "ResultLabel"));
            } catch (e) {}

            return parts.filter(str => str).join(" ");
          ]]>
        </body>
      </method>

      <method name="maybeSetupSpeculativeConnect">
        <parameter name="aUriString"/>
        <body><![CDATA[
          try {
            let uri = makeURI(aUriString);
            Services.io.speculativeConnect2(uri, gBrowser.contentPrincipal, null);
          } catch (ex) {
          }
        ]]></body>
      </method>

      <method name="onResultsAdded">
        <body>
          <![CDATA[
            if (this.selectedIndex == -1 && this._isFirstResultHeuristic) {
              this.richlistbox.suppressMenuItemEvent = true;
              this.input.controller.setInitiallySelectedIndex(0);
              this.richlistbox.suppressMenuItemEvent = false;
            }
            if (!this.input.gotResultForCurrentQuery &&
                this.input.speculativeConnectEnabled &&
                !this.input.inPrivateContext &&
                this.input.mController.matchCount > 0) {
              let firstStyle = this.input.mController.getStyleAt(0);
              if (firstStyle.includes("autofill")) {
                let uri = this.input.mController.getFinalCompleteValueAt(0);

                if (!uri.includes("://")) {
                  uri = "http://" + uri;
                }
                this.maybeSetupSpeculativeConnect(uri);
              } else if (firstStyle.includes("searchengine") &&
                         this.input.browserSearchSuggestEnabled &&
                         this.input.urlbarSearchSuggestEnabled) {

                let engine = Services.search.currentEngine;
                engine.speculativeConnect({window,
                                           originAttributes: gBrowser.contentPrincipal.originAttributes});
              }
            }

            this.footer.collapsed = false;
            this.input.tabScrolling = true;

            this.input.gotResultForCurrentQuery = true;
            this.input.maybeReplayDeferredKeyEvents();
          ]]>
        </body>
      </method>

      <method name="_onSearchBegin">
        <body><![CDATA[
          this.input.controller.setInitiallySelectedIndex(0);

          this.oneOffSearchButtons.selectedButton = null;
        ]]></body>
      </method>

      <field name="_addonIframe">null</field>
      <field name="_addonIframeOwner">null</field>
      <field name="_addonIframeOverriddenFunctionsByName">{}</field>

      <field name="_addonIframeOverrideFunctionNames">[
        "_invalidate",
      ]</field>

      <field name="_addonIframeHiddenAnonids">[
        "search-suggestions-notification",
        "richlistbox",
        "one-off-search-buttons",
      ]</field>
      <field name="_addonIframeHiddenDisplaysByAnonid">{}</field>

      <method name="initAddonIframe">
        <parameter name="owner"/>
        <parameter name="overrides"/>
        <body><![CDATA[
          if (this._addonIframeOwner) {
            return null;
          }

          for (let name of this._addonIframeOverrideFunctionNames) {
            if (typeof(overrides[name]) != "function") {
              throw new Error(
                "Override for method '" + name + "' must be given"
              );
            }
          }

          this._addonIframeOwner = owner;
          this._addonIframe = this._makeAddonIframe();
          this._addonIframeOverriddenFunctionsByName = {};
          for (let name of this._addonIframeOverrideFunctionNames) {
            this._addonIframeOverriddenFunctionsByName[name] = this[name];
            this[name] = overrides[name];
          }
          return this._addonIframe;
        ]]></body>
      </method>

      <method name="destroyAddonIframe">
        <parameter name="owner"/>
        <body><![CDATA[
          if (this._addonIframeOwner != owner) {
            throw new Error("You're not the iframe owner");
          }
          this._addonIframeOwner = null;
          this._addonIframe.remove();
          this._addonIframe = null;
          for (let anonid of this._addonIframeHiddenAnonids) {
            let child = document.getAnonymousElementByAttribute(
              this, "anonid", anonid
            );
            child.style.display =
              this._addonIframeHiddenDisplaysByAnonid[anonid];
          }
          for (let name in this._addonIframeOverriddenFunctionsByName) {
            this[name] = this._addonIframeOverriddenFunctionsByName[name];
          }
          this._addonIframeOverriddenFunctionsByName = {};
        ]]></body>
      </method>

      <method name="_makeAddonIframe">
        <body><![CDATA[
          this._addonIframeHiddenDisplaysByAnonid = {};
          for (let anonid of this._addonIframeHiddenAnonids) {
            let child = document.getAnonymousElementByAttribute(
              this, "anonid", anonid
            );
            this._addonIframeHiddenDisplaysByAnonid[anonid] =
              child.style.display;
            child.style.display = "none";
          }
          let XUL_NS =
            "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
          let iframe = document.createElementNS(XUL_NS, "iframe");
          iframe.setAttribute("type", "content");
          iframe.setAttribute("flex", "1");
          iframe.style.transition = "height 100ms";
          this.appendChild(iframe);
          return iframe;
        ]]></body>
      </method>

    </implementation>
    <handlers>

      <handler event="SelectedOneOffButtonChanged"><![CDATA[
        this._selectedOneOffChanged();
      ]]></handler>

      <handler event="mousedown"><![CDATA[

        event.preventDefault();

        if (!this.input.speculativeConnectEnabled) {
          return;
        }
        if (event.button == 2) {

          return;
        }

        let elt = event.originalTarget;
        while (elt && elt.localName != "richlistitem" && elt != this) {
          elt = elt.parentNode;
        }
        if (!elt || elt.localName != "richlistitem") {
          return;
        }

        if (this.input.controller.matchCount <= this.selectedIndex) {
          return;
        }

        let url = this.input.controller.getFinalCompleteValueAt(this.selectedIndex);

        if (url.startsWith("http") && this.selectedIndex > 0) {
          this.maybeSetupSpeculativeConnect(url);
        } else if (url.startsWith("moz-action:remotetab")) {

          const MOZ_ACTION_REGEX = /^moz-action:([^,]+),(.*)$/;
          if (!MOZ_ACTION_REGEX.test(url))
            return;

          let params = JSON.parse(url.match(MOZ_ACTION_REGEX)[2]);
          if (params.url) {
            this.maybeSetupSpeculativeConnect(decodeURIComponent(params.url));
          }
        }

      ]]></handler>

    </handlers>
  </binding>
  
  <binding id="autocomplete-richlistitem" extends="chrome://global/content/bindings/richlistbox.xml#richlistitem">

    <content align="start"
             onoverflow="this._onOverflow();"
             onunderflow="this._onUnderflow();">
	<xul:hbox>
		<xul:hbox align="center">
		  <xul:image anonid="site-icon"
					 class="ac-site-icon"
					 xbl:inherits="src=image,selected,type"/>
		  <xul:hbox class="ac-title"
					align="center"
					xbl:inherits="selected">
			<xul:description class="ac-text-overflow-container">
			  <xul:description anonid="title-text"
							   class="ac-title-text"
							   xbl:inherits="selected"/>
			</xul:description>
			<xul:hbox anonid="tags"
					class="ac-tags"
					align="center"
					xbl:inherits="selected">
			  <xul:description class="ac-text-overflow-container">
				<xul:description anonid="tags-text"
							   class="ac-tags-text"
							   xbl:inherits="selected"/>
			  </xul:description>
			</xul:hbox>
		  </xul:hbox>
		</xul:hbox>
		<xul:spacer flex="1" id="ibox-spacer"/>
		<xul:hbox align="end" id="ibox-box">
		  <xul:image anonid="type-icon"
				   class="ac-type-icon"
				   xbl:inherits="selected,current,type"/>
		</xul:hbox>
	</xul:hbox>
	<xul:hbox align="center">
      <xul:hbox anonid="separator"
                class="ac-separator"
                align="center"
                xbl:inherits="selected,actiontype,type">
        <xul:description class="ac-separator-text">â€”</xul:description>
      </xul:hbox>
      <xul:hbox class="ac-url"
                align="center"
                xbl:inherits="selected,actiontype">
        <xul:description class="ac-text-overflow-container">
          <xul:description anonid="url-text"
                           class="ac-url-text"
                           xbl:inherits="selected"/>
        </xul:description>
      </xul:hbox>
      <xul:hbox class="ac-action"
                align="center"
                xbl:inherits="selected,actiontype">
        <xul:description class="ac-text-overflow-container">
          <xul:description anonid="action-text"
                           class="ac-action-text"
                           xbl:inherits="selected"/>
        </xul:description>
      </xul:hbox>
	</xul:hbox>
    </content>

    <implementation implements="nsIDOMXULSelectControlItemElement">
      <constructor>
        <![CDATA[
          this._typeIcon = document.getAnonymousElementByAttribute(
            this, "anonid", "type-icon"
          );
          this._siteIcon = document.getAnonymousElementByAttribute(
            this, "anonid", "site-icon"
          );
          this._titleText = document.getAnonymousElementByAttribute(
            this, "anonid", "title-text"
          );
          this._tags = document.getAnonymousElementByAttribute(
            this, "anonid", "tags"
          );
          this._tagsText = document.getAnonymousElementByAttribute(
            this, "anonid", "tags-text"
          );
          this._separator = document.getAnonymousElementByAttribute(
            this, "anonid", "separator"
          );
          this._urlText = document.getAnonymousElementByAttribute(
            this, "anonid", "url-text"
          );
          this._actionText = document.getAnonymousElementByAttribute(
            this, "anonid", "action-text"
          );
          this._adjustAcItem();
        ]]>
      </constructor>

      <method name="_cleanup">
        <body>
        <![CDATA[
          this.removeAttribute("url");
          this.removeAttribute("image");
          this.removeAttribute("title");
          this.removeAttribute("text");
          this.removeAttribute("displayurl");
        ]]>
        </body>
      </method>

      <property name="label" readonly="true">
        <getter>
          <![CDATA[
            let parts = [
              this.getAttribute("title"),
              this.getAttribute("displayurl"),
            ];
            let label = parts.filter(str => str).join(" ")

            let panel = this.parentNode.parentNode;
            if (panel.createResultLabel) {
              return panel.createResultLabel(this, label);
            }

            return label;
          ]]>
        </getter>
      </property>

      <property name="_stringBundle">
        <getter><![CDATA[
          if (!this.__stringBundle) {
            this.__stringBundle = Services.strings.createBundle("chrome://global/locale/autocomplete.properties");
          }
          return this.__stringBundle;
        ]]></getter>
      </property>

      <field name="_boundaryCutoff">null</field>

      <property name="boundaryCutoff" readonly="true">
        <getter>
          <![CDATA[
          if (!this._boundaryCutoff) {
            this._boundaryCutoff =
              Components.classes["@mozilla.org/preferences-service;1"].
              getService(Components.interfaces.nsIPrefBranch).
              getIntPref("toolkit.autocomplete.richBoundaryCutoff");
          }
          return this._boundaryCutoff;
          ]]>
        </getter>
      </property>

      <field name="_inOverflow">false</field>

      <method name="_onOverflow">
        <body>
          <![CDATA[
          this._inOverflow = true;
          this._handleOverflow();
          ]]>
        </body>
      </method>

      <method name="_onUnderflow">
        <body>
          <![CDATA[
          this._inOverflow = false;
          this._handleOverflow();
          ]]>
        </body>
      </method>

      <method name="_getBoundaryIndices">
        <parameter name="aText"/>
        <parameter name="aSearchTokens"/>
        <body>
          <![CDATA[
          if (aSearchTokens == "")
            return [0, aText.length];

          let regions = [];
          for (let search of Array.prototype.slice.call(aSearchTokens)) {
            let matchIndex = -1;
            let searchLen = search.length;

            let lowerText = aText.substr(0, this.boundaryCutoff).toLowerCase();
            while ((matchIndex = lowerText.indexOf(search, matchIndex + 1)) >= 0) {
              regions.push([matchIndex, matchIndex + searchLen]);
            }
          }

          regions = regions.sort((a, b) => {
            let start = a[0] - b[0];
            return (start == 0) ? a[1] - b[1] : start;
          });

          let start = 0;
          let end = 0;
          let boundaries = [];
          let len = regions.length;
          for (let i = 0; i < len; i++) {
            let region = regions[i];
            if (region[0] > end) {
              boundaries.push(start);
              boundaries.push(end);

              start = region[0];
            }

            end = Math.max(end, region[1]);
          }

          boundaries.push(start);
          boundaries.push(end);

          if (end < aText.length)
            boundaries.push(aText.length);

          return boundaries.slice(1);
          ]]>
        </body>
      </method>

      <method name="_getSearchTokens">
        <parameter name="aSearch"/>
        <body>
          <![CDATA[
          let search = aSearch.toLowerCase();
          return search.split(/\s+/);
          ]]>
        </body>
      </method>

      <method name="_setUpDescription">
        <parameter name="aDescriptionElement"/>
        <parameter name="aText"/>
        <parameter name="aNoEmphasis"/>
        <body>
          <![CDATA[
          if (!aDescriptionElement) {
            return;
          }
          while (aDescriptionElement.hasChildNodes())
            aDescriptionElement.firstChild.remove();

          if (aNoEmphasis) {
            aDescriptionElement.appendChild(document.createTextNode(aText));
            return;
          }

          let search = this.getAttribute("text");
          let tokens = this._getSearchTokens(search);
          let indices = this._getBoundaryIndices(aText, tokens);

          this._appendDescriptionSpans(indices, aText, aDescriptionElement,
                                       aDescriptionElement);
          ]]>
        </body>
      </method>

      <method name="_appendDescriptionSpans">
        <parameter name="indices"/>
        <parameter name="text"/>
        <parameter name="spansParentElement"/>
        <parameter name="descriptionElement"/>
        <body>
          <![CDATA[
          let next;
          let start = 0;
          let len = indices.length;
          for (let i = indices[0] == 0 ? 1 : 0; i < len; i++) {
            next = indices[i];
            let spanText = text.substr(start, next - start);
            start = next;

            if (i % 2 == 0) {
              let span = spansParentElement.appendChild(
                document.createElementNS("http://www.w3.org/1999/xhtml", "span"));
              this._setUpEmphasisSpan(span, descriptionElement);
              span.textContent = spanText;
            } else {
              spansParentElement.appendChild(document.createTextNode(spanText));
            }
          }
          ]]>
        </body>
      </method>

      <method name="_setUpTags">
        <parameter name="tags"/>
        <body>
          <![CDATA[
          while (this._tagsText.hasChildNodes()) {
            this._tagsText.firstChild.remove();
          }

          let anyTagsMatch = false;

          for (let tag of tags) {
            let search = this.getAttribute("text");
            let tokens = this._getSearchTokens(search);
            let indices = this._getBoundaryIndices(tag, tokens);

            if (indices.length == 2 &&
                indices[0] == 0 &&
                indices[1] == tag.length) {
              continue;
            }

            anyTagsMatch = true;

            let tagSpan =
              document.createElementNS("http://www.w3.org/1999/xhtml", "span");
            tagSpan.classList.add("ac-tag");
            this._tagsText.appendChild(tagSpan);

            this._appendDescriptionSpans(indices, tag, tagSpan, this._tagsText);
          }

          return anyTagsMatch;
          ]]>
        </body>
      </method>

      <method name="_setUpEmphasisSpan">
        <parameter name="aSpan"/>
        <parameter name="aDescriptionElement"/>
        <body>
          <![CDATA[
          aSpan.classList.add("ac-emphasize-text");
          switch (aDescriptionElement) {
            case this._titleText:
              aSpan.classList.add("ac-emphasize-text-title");
              break;
            case this._tagsText:
              aSpan.classList.add("ac-emphasize-text-tag");
              break;
            case this._urlText:
              aSpan.classList.add("ac-emphasize-text-url");
              break;
            case this._actionText:
              aSpan.classList.add("ac-emphasize-text-action");
              break;
          }
          ]]>
        </body>
      </method>

      <method name="_generateEmphasisPairs">
        <parameter name="aSourceString"/>
        <parameter name="aReplacements"/>
        <body>
          <![CDATA[
            let pairs = [];

            let parts = aSourceString.split(/(%(?:[0-9]+\$)?S)/);

            for (let part of parts) {
              if (part.length === 0)
                continue;

              let match = part.match(/^%(?:([0-9]+)\$)?S$/);

              if (match) {
                let index = (match[1] || 1) - 1;

                if (index >= 0 && index < aReplacements.length) {
                  pairs.push([...aReplacements[index]]);
                }
              } else {
                pairs.push([part]);
              }
            }

            return pairs;
          ]]>
        </body>
      </method>

      <method name="_setUpEmphasisedSections">
        <parameter name="aDescriptionElement"/>
        <parameter name="aTextPairs"/>
        <body>
          <![CDATA[
          while (aDescriptionElement.hasChildNodes())
            aDescriptionElement.firstChild.remove();

          for (let [text, emphasise] of aTextPairs) {
            if (emphasise) {
              let span = aDescriptionElement.appendChild(
                document.createElementNS("http://www.w3.org/1999/xhtml", "span"));
              span.textContent = text;
              switch (emphasise) {
                case "match":
                  this._setUpEmphasisSpan(span, aDescriptionElement);
                  break;
              }
            } else {
              aDescriptionElement.appendChild(document.createTextNode(text));
            }
          }
          ]]>
        </body>
      </method>

      <field name="_textToSubURI">null</field>
      <method name="_unescapeUrl">
        <parameter name="url"/>
        <body>
          <![CDATA[
          if (!this._textToSubURI) {
            this._textToSubURI =
              Components.classes["@mozilla.org/intl/texttosuburi;1"]
                        .getService(Components.interfaces.nsITextToSubURI);
          }
          return this._textToSubURI.unEscapeURIForUI("UTF-8", url);
          ]]>
        </body>
      </method>


      <method name="_reuseAcItem">
        <body>
          <![CDATA[
            let action = this._parseActionUrl(this.getAttribute("url"));
            let popup = this.parentNode.parentNode;

            if (!action ||
                action.type != "searchengine" ||
                !popup.overrideSearchEngineName ||
                action.params.engineName == popup.overrideSearchEngineName) {

              this.collapsed = false;

              let dwu = window.getInterface(Ci.nsIDOMWindowUtils);
              let popupWidth = dwu.getBoundsWithoutFlushing(this.parentNode).width;
              if (!this._previousPopupWidth || this._previousPopupWidth != popupWidth) {
                this._previousPopupWidth = popupWidth;
                this.handleOverUnderflow();
              }

              return true;
            }

            return false;
          ]]>
        </body>
      </method>


      <method name="_adjustAcItem">
        <body>
          <![CDATA[
          let originalUrl = this.getAttribute("ac-value");
          let title = this.getAttribute("ac-comment");
          this.setAttribute("url", originalUrl);
          this.setAttribute("image", this.getAttribute("ac-image"));
          this.setAttribute("title", title);
          this.setAttribute("text", this.getAttribute("ac-text"));

          let popup = this.parentNode.parentNode;
          let titleLooksLikeUrl = false;
          let displayUrl;
          let emphasiseUrl = true;

          let type = this.getAttribute("originaltype");
          let types = new Set(type.split(/\s+/));
          let initialTypes = new Set(types);

          types.delete("action");
          types.delete("autofill");
          types.delete("heuristic");
          type = [...types][0] || "";

          let action;

          if (initialTypes.has("autofill")) {
            action = {
              type: "visiturl",
              params: {
                url: this.getAttribute("title"),
              },
            };
          }

          this.removeAttribute("actiontype");
          this.classList.remove("overridable-action");

          if (initialTypes.has("action") || action) {
            action = action || this._parseActionUrl(originalUrl);
            this.setAttribute("actiontype", action.type);

            if (action.type == "switchtab") {
              this.classList.add("overridable-action");
              displayUrl = this._unescapeUrl(action.params.url);
              let desc = this._stringBundle.GetStringFromName("switchToTab2");
              this._setUpDescription(this._actionText, desc, true);
            } else if (action.type == "remotetab") {
              displayUrl = this._unescapeUrl(action.params.url);
              let desc = action.params.deviceName;
              this._setUpDescription(this._actionText, desc, true);
            } else if (action.type == "searchengine") {
              emphasiseUrl = false;

              let {engineName, searchSuggestion, searchQuery} = action.params;

              let override = popup.overrideSearchEngineName;
              if (override && override != engineName) {
                engineName = override;
                action.params.engineName = override;
                let newURL =
                  PlacesUtils.mozActionURI(action.type, action.params);
                this.setAttribute("url", newURL);
              }

              let engineStr =
                this._stringBundle.formatStringFromName("searchWithEngine",
                                                        [engineName], 1);
              this._setUpDescription(this._actionText, engineStr, true);

              let pairs;
              if (searchSuggestion) {
                let idx = searchSuggestion.indexOf(searchQuery);
                if (idx >= 0) {
                  pairs = [
                    [searchSuggestion.substring(0, idx), ""],
                    [searchQuery, "match"],
                    [searchSuggestion.substring(idx + searchQuery.length), ""],
                  ];
                } else {
                  pairs = [
                    [searchSuggestion, ""],
                  ];
                }
              } else {
                pairs = [
                  [searchQuery, ""],
                ];
              }
              let interpStr = pairs.map((pair, i) => `%${i + 1}$S`).join("");
              title = this._generateEmphasisPairs(interpStr, pairs);

              if (!action.params.alias && !initialTypes.has("favicon")) {
                this.removeAttribute("image");
              }
            } else if (action.type == "visiturl") {
              emphasiseUrl = false;
              displayUrl = this._unescapeUrl(action.params.url);
              title = displayUrl;
              titleLooksLikeUrl = true;
              let visitStr = this._stringBundle.GetStringFromName("visit");
              this._setUpDescription(this._actionText, visitStr, true);
            } else if (action.type == "extension") {
              let content = action.params.content;
              displayUrl = content;
              this._setUpDescription(this._actionText, content, true);
            }
          }

          if (!displayUrl) {
            let input = popup.input;
            let url = typeof(input.trimValue) == "function" ?
                      input.trimValue(originalUrl) :
                      originalUrl;
            displayUrl = this._unescapeUrl(url);
          }

          if (popup.textRunsMaxLen) {
            displayUrl = displayUrl.substr(0, popup.textRunsMaxLen);
          }
          this.setAttribute("displayurl", displayUrl);

          if (!title) {
            title = displayUrl;
            titleLooksLikeUrl = true;
            try {
              let uri = Services.io.newURI(originalUrl);

              if (uri.host)
                title = uri.host;
            } catch (e) {}
          }

          this._tags.setAttribute("empty", "true");

          if (type == "tag" || type == "bookmark-tag") {

            let tags;
            [, title, tags] = title.match(/^(.+) \u2013 (.+)$/);

            let sortedTags = tags.split(/\s*,\s*/).sort((a, b) => {
              return a.localeCompare(a);
            });

            let anyTagsMatch = this._setUpTags(sortedTags);
            if (anyTagsMatch) {
              this._tags.removeAttribute("empty");
            }
            if (type == "bookmark-tag") {
              type = "bookmark";
            }
          } else if (type == "keyword") {

            emphasiseUrl = false;
            let keywordArg = this.getAttribute("text").replace(/^[^\s]+\s*/, "");
            if (!keywordArg) {

              type = "visiturl";
              this.setAttribute("actiontype", "visiturl");
              let visitStr = this._stringBundle.GetStringFromName("visit");
              this._setUpDescription(this._actionText, visitStr, true);
            } else {
              let pairs = [[title, ""], [keywordArg, "match"]];
              let interpStr =
                this._stringBundle.GetStringFromName("bookmarkKeywordSearch");
              title = this._generateEmphasisPairs(interpStr, pairs);

              this._setUpDescription(this._actionText, "", false);
            }
          }

          this.setAttribute("type", type);

          if (titleLooksLikeUrl) {
            this._titleText.setAttribute("lookslikeurl", "true");
          } else {
            this._titleText.removeAttribute("lookslikeurl");
          }

          if (Array.isArray(title)) {

            if (popup.textRunsMaxLen) {
              title = title.map(t => t.substr(0, popup.textRunsMaxLen));
            }
            this._setUpEmphasisedSections(this._titleText, title);
          } else {

            if (popup.textRunsMaxLen) {
              title = title.substr(0, popup.textRunsMaxLen);
            }
            this._setUpDescription(this._titleText, title, false);
          }
          this._setUpDescription(this._urlText, displayUrl, !emphasiseUrl);

          let wasInOverflow = this._inOverflow;
          this._removeMaxWidths();
          if (wasInOverflow && this._inOverflow) {
            this._handleOverflow();
          }
          ]]>
        </body>
      </method>

      <method name="_removeMaxWidths">
        <body>
          <![CDATA[
          if (this._hasMaxWidths) {
            this._titleText.style.removeProperty("max-width");
            this._tagsText.style.removeProperty("max-width");
            this._urlText.style.removeProperty("max-width");
            this._actionText.style.removeProperty("max-width");
            this._hasMaxWidths = false;
          }
          ]]>
        </body>
      </method>

      <method name="_handleOverflow">
        <body><![CDATA[
          let itemRect = this.parentNode.getBoundingClientRect();
          let titleRect = this._titleText.getBoundingClientRect();
          let tagsRect = this._tagsText.getBoundingClientRect();
          let separatorRect = this._separator.getBoundingClientRect();
          let urlRect = this._urlText.getBoundingClientRect();
          let actionRect = this._actionText.getBoundingClientRect();
          let separatorURLActionWidth =
            separatorRect.width + Math.max(urlRect.width, actionRect.width);

          let dir = this.getAttribute("dir");
          let titleStart = dir == "rtl" ? itemRect.right - titleRect.right
                                        : titleRect.left - itemRect.left;

          let popup = this.parentNode.parentNode;
          let itemWidth = itemRect.width - titleStart - popup.overflowPadding;

          if (this._tags.hasAttribute("empty")) {
            tagsRect.width = 0;
          }

          let titleTagsWidth = titleRect.width + tagsRect.width;
          if (titleTagsWidth + separatorURLActionWidth > itemWidth) {

            let titleTagsPct = 0.66;

            let titleTagsAvailable = itemWidth - separatorURLActionWidth;
            let titleTagsMaxWidth = Math.max(
              titleTagsAvailable,
              itemWidth * titleTagsPct
            );
            if (titleTagsWidth > titleTagsMaxWidth) {

              let titlePct = 0.33;

              let titleAvailable = titleTagsMaxWidth - tagsRect.width;
              let titleMaxWidth = Math.max(
                titleAvailable,
                titleTagsMaxWidth * titlePct
              );
              let tagsAvailable = titleTagsMaxWidth - titleRect.width;
              let tagsMaxWidth = Math.max(
                tagsAvailable,
                titleTagsMaxWidth * (1 - titlePct)
              );
              this._titleText.style.maxWidth = titleMaxWidth + "px";
              this._tagsText.style.maxWidth = tagsMaxWidth + "px";
            }
            let urlActionMaxWidth = Math.max(
              itemWidth - titleTagsWidth,
              itemWidth * (1 - titleTagsPct)
            );
            urlActionMaxWidth -= separatorRect.width;
            this._urlText.style.maxWidth = urlActionMaxWidth + "px";
            this._actionText.style.maxWidth = urlActionMaxWidth + "px";
            this._hasMaxWidths = true;
          }
        ]]></body>
      </method>

      <method name="handleOverUnderflow">
        <body>
          <![CDATA[
          this._removeMaxWidths();
          this._handleOverflow();
          ]]>
        </body>
      </method>

      <method name="_parseActionUrl">
        <parameter name="aUrl"/>
        <body><![CDATA[
          if (!aUrl.startsWith("moz-action:"))
            return null;

          let [, type, params] = aUrl.match(/^moz-action:([^,]+),(.*)$/);

          let action = {
            type,
          };

          try {
            action.params = JSON.parse(params);
            for (let key in action.params) {
              action.params[key] = decodeURIComponent(action.params[key]);
            }
          } catch (e) {

            action.params = {
              url: params,
            }
          }

          return action;
        ]]></body>
      </method>
    </implementation>

    <handlers>

      <handler event="mousedown"><![CDATA[

        let control = this.control;
        if (!control || control.disabled) {
          return;
        }
        if (!this.selected) {
          control.selectItem(this);
        }
        control.currentItem = this;
      ]]></handler>

      <handler event="mouseover"><![CDATA[
        let mouseDown = event.buttons & 0b111;
        if (!mouseDown) {
          return;
        }

        let control = this.control;
        if (!control || control.disabled) {
          return;
        }
        if (!this.selected) {
          control.selectItem(this);
        }
        control.currentItem = this;
      ]]></handler>
    </handlers>
  </binding>

</bindings>
